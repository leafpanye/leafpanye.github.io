<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS面向对象的程序设计]]></title>
      <url>%2F2017%2F06%2F07%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[面向对象的语言有一个标志，即拥有类的概念，抽象实例对象的公共属性与方法，基于类可以创建任意多个实例对象，一般具有封装、继承、多态的特性！但JS中对象与纯面向对象语言中的对象是不同的，ECMA标准定义JS中对象：无序属性的集合，其属性可以包含基本值、对象或者函数。可以简单理解为JS的对象是一组无序的值，其中的属性或方法都有一个名字，根据这个名字可以访问相映射的值（值可以是基本值/对象/方法）。 理解对象第一种：基于Object对象 var person = new Object(); person.name = &apos;My Name&apos;; person.age = 18; person.getName = function(){ return this.name; } 第二种：对象字面量方式（比较清楚的查找对象包含的属性及方法） var person = { name : &apos;My name&apos;, age : 18, getName : function(){ return this.name; } } JS的对象可以使用‘.’操作符动态的扩展其属性，可以使用’delete’操作符或将属性值设置为’undefined’来删除属性。如下： person.newAtt=’new Attr’;//添加属性 alert(person.newAtt);//new Attr delete person.age; alert(person.age);//undefined(删除属性后值为undefined); 对象属性类型ECMA-262第5版定义了JS对象属性中特征（用于JS引擎，外部无法直接访问）。ECMAScript中有两种属性：数据属性和访问器属性 数据属性：数据属性指包含一个数据值的位置，可在该位置读取或写入值，该属性有4个供述其行为的特性：[[configurable]]:表示能否使用delete操作符删除从而重新定义，或能否修改为访问器属性。默认为true;[[Enumberable]]:表示是否可通过for-in循环返回属性。默认true;[[Writable]]:表示是否可修改属性的值。默认true;[[Value]]:包含该属性的数据值。读取/写入都是该值。默认为undefined;如上面实例对象person中定义了name属性，其值为’My name’,对该值的修改都反正在这个位置要修改对象属性的默认特征（默认都为true)，可调用Object.defineProperty()方法，它接收三个参数：属性所在对象，属性名和一个描述符对象（必须是：configurable、enumberable、writable和value，可设置一个或多个值）。如下：（浏览器支持：IE9+、Firefox 4+、Chrome、Safari5+） var person = {}; Object.defineProperty(person, &apos;name&apos;, { configurable: false, writable: false, value: &apos;Jack&apos; }); alert(person.name);//Jack delete person.name; person.name = &apos;lily&apos;; alert(person.name);//Jack 可以看出，delete及重置person.name的值都没有生效，这就是因为调用defineProperty函数修改了对象属性的特征；值得注意的是一旦将configurable设置为false，则无法再使用defineProperty将其修改为true（执行会报错：can’t redefine non-configurable property）; 访问器属性：它主要包括一对getter和setter函数，在读取访问器属性时，会调用getter返回有效值；写入访问器属性时，调用setter，写入新值；该属性有以下4个特征：[[Configurable]]:是否可通过delete操作符删除重新定义属性；[[Numberable]]:是否可通过for-in循环查找该属性；[[Get]]:读取属性时调用，默认：undefined;[[Set]]:写入属性时调用，默认：undefined;访问器属性不能直接定义，必须使用defineProperty()来定义，如下： var person = { _age: 18 }; Object.defineProperty(person, &apos;isAdult&apos;, { get: function () { if (this._age &gt;= 18) { return true; } else { return false; } } }); alert(person.isAdult?&apos;成年&apos;:&apos;未成年&apos;);//成年 从上面可知，定义访问器属性时getter与setter函数不是必须的,并且，在定义getter与setter时不能指定属性的configurable及writable特性；此外，ECMA-262（5）还提供了一个Object.defineProperties()方法，可以用来一次性定义多个属性的特性： var person = {}; Object.defineProperties(person,{ _age:{ value:19 }, isAdult:{ get: function () { if (this._age &gt;= 18) { return true; } else { return false; } } } }); alert(person.isAdult?&apos;成年&apos;:&apos;未成年&apos;);//成年 上述代码使用Object.defineProperties()方法同时定义了_age及isAudlt两个属性的特性此外，使用Object.getOwnPropertyDescriptor()方法可以取得给定属性的特性： var descriptor = Object.getOwnPropertyDescriptor(person,&apos;_age&apos;); alert(descriptor.value);//19 对于数据属性，可以取得：configurable,enumberable,writable和value；对于访问器属性，可以取得：configurable,enumberable,get和set 创建对象使用Object构造函数或对象字面量都可以创建对象，但缺点是创建多个对象时，会产生大量的重复代码，因此下面介绍可解决这个问题的创建对象的方法 工厂模式function createPerson(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.getName = function () { return this.name; } return o;//使用return返回生成的对象实例 } var person = createPerson(&apos;Jack&apos;, 19, &apos;SoftWare Engineer&apos;); 创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的。 构造函数模式function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.getName = function () { return this.name; } } var person1 = new Person(&apos;Jack&apos;, 19, &apos;SoftWare Engineer&apos;); var person2 = new Person(&apos;Liye&apos;, 23, &apos;Mechanical Engineer&apos;); 使用自定义的构造函数（与普通函数一样，只是用它来创建对象），定义对象类型（如：Person）的属性和方法。它与工厂方法区别在于： 没有显式地创建对象； 直接将属性和方法赋值给this对象； 没有return语句； 此外，要创建Person的实例，必须使用new关键字，以Person函数为构造函数，传递参数完成对象创建；实际创建经过以下4个过程： 创建一个对象 将函数的作用域赋给新对象（因此this指向这个新对象，如：person1） 执行构造函数的代码 返回该对象 上述由Person构造函数生成的两个对象person1与person2都是Person的实例，因此可以使用instanceof判断，并且因为所有对象都继承Object，因此person1 instanceof Object也返回真： alert(person1 instanceof Person);//true; alert(person2 instanceof Person);//true; alert(person1 instanceof Object);//true; alert(person1.constructor === person2.constructor);//ture; 虽然构造函数方式比较不错，但也存在缺点，那就是在创建对象时，特别针对对象的属性指向函数时，会重复的创建函数实例，以上述代码为基础，可以改写为： function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.getName = new Function () {//改写后效果与原代码相同，不过是为了方便理解 return this.name; } } 上述代码，创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。当然，可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果，如下所示： function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.getName = getName; } function getName() {//到处是代码，看着乱！！ return this.name; } 原型模式JS每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，它是所有通过new操作符使用函数创建的实例的原型对象。原型对象最大特点是，所有对象实例共享它所包含的属性和方法，也就是说，所有在原型对象中创建的属性或方法都直接被所有对象实例共享。 function Person(){ } Person.prototype.name = &apos;Jack&apos;;//使用原型来添加属性 Person.prototype.age = 29; Person.prototype.getName = function(){ return this.name; } var person1 = new Person(); alert(person1.getName());//Jack var person2 = new Person(); alert(person1.getName === person2.getName);//true;共享一个原型对象的方法 原型是指向原型对象的，这个原型对象与构造函数没有太大关系，唯一的关系是函数的prototype是指向这个原型对象！而基于构造函数创建的对象实例也包含一个内部指针为：[[prototype]]指向原型对象。实例属性或方法的访问过程是一次搜索过程： 首先从对象实例本身开始，如果找到属性就直接返回该属性值； 如果实例本身不存在要查找属性，就继续搜索指针指向的原型对象，在其中查找给定名字的属性，如果有就返回； 基于以上分析，原型模式创建的对象实例，其属性是共享原型对象的；但也可以自己实例中再进行定义，在查找时，就不从原型对象获取，而是根据搜索原则，得到本实例的返回；简单来说，就是实例中属性会屏蔽原型对象中的属性；原型与in操作符一句话：无论原型中属性，还是对象实例的属性，都可以使用in操作符访问到；要想判断是否是实例本身的属性可以使用object.hasOwnProperty(‘attr’)来判断；原生对象中原型原生对象中原型与普通对象的原型一样，可以添加/修改属性或方法，如以下代码为所有字符串对象添加去左右空白原型方法： String.prototype.trim = function(){ return this.replace(/^\s+/,&apos;&apos;).replace(/\s+$/,&apos;&apos;); } var str = &apos; word space &apos;; alert(&apos;!&apos;+str.trim()+&apos;!&apos;);//!word space! 原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例： function Person() { } Person.prototype.name = &apos;Jack&apos;; Person.prototype.lessons = [&apos;Math&apos;,&apos;Physics&apos;]; var person1 = new Person(); person1.lessons.push(&apos;Biology&apos;); var person2 = new Person(); alert(person2.lessons);//Math,Physics,Biology，person1修改影响了person2 组合构造函数及原型模式目前最为常用的定义类型方式，是组合构造函数模式与原型模式。构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.lessons = [&apos;Math&apos;, &apos;Physics&apos;]; } Person.prototype = { constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person getName: function () { return this.name; } } var person1 = new Person(&apos;Jack&apos;, 19, &apos;SoftWare Engneer&apos;); person1.lessons.push(&apos;Biology&apos;); var person2 = new Person(&apos;Lily&apos;, 39, &apos;Mechanical Engneer&apos;); alert(person1.lessons);//Math,Physics,Biology alert(person2.lessons);//Math,Physics alert(person1.getName === person2.getName);//true,//共享原型中定义方法 在所接触的JS库中，jQuery类型的封装就是使用组合模式来实例的！！！ 动态原型模式组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中： function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.lessons = [&apos;Math&apos;, &apos;Physics&apos;]; } if (typeof this.getName != &apos;function&apos;) {//通过判断实例封装 Person.prototype = { constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person getName: function () { return this.name; } } } var person1 = new Person(&apos;Jack&apos;, 19, &apos;SoftWare Engneer&apos;); person1.lessons.push(&apos;Biology&apos;); var person2 = new Person(&apos;Lily&apos;, 39, &apos;Mechanical Engneer&apos;); alert(person1.lessons);//Math,Physics,Biology alert(person2.lessons);//Math,Physics alert(person1.getName === person2.getName);//true,//共享原型中定义方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS学习之PhoneCat安装]]></title>
      <url>%2F2017%2F05%2F04%2FAngularJS%E5%AD%A6%E4%B9%A0%E4%B9%8BPhoneCat%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[最近开始研究AngularJS了，照着官网的教程安装了PhoneCat的实例。 安装git官网下载的很慢，所以我从360下载了git。装好了就可以使用git命令行工具了。 下载angular-phonecat运行以下命令以克隆放置在GitHub上的 angular-phonecat repository： git clone --depth=14 https://github.com/angular/angular-phonecat.git 该命令在你当前的目录中创建了angular-phonecat目录。该--depth=14的选项仅仅是告诉Git只拉下来最后的14次提交。这样使下载更小更快。把你当前的目录变成angular-phonecat。 cd angular-phonecat 安装Node.js很简单的，官网下载安装就可以了，安装好后，可以检查已经安装的node.js版本： node --version 一旦你已经在你的机器上安装了Node.js，你可以依靠运行以下代码下载该工具。 npm install 这个命令读取了angular-phonecat的package.json文件，并把以下工具下载到node_modules目录中： Bower - 客户端代码包管理工具 Http-Server - 简单的本地静态web服务器 Karma - 单元测试运行器 Protractor - 端到端测试运行器 运行npm install还将自动使用bower以把该Angular框架下载到app/bower_component目录。 运行开发Web服务器虽然Angular应用程序是纯客户端代码，而且能够直接从文件系统中，在web浏览器中打开它们，但是最好从一个HTTP web服务器中供应它们。特别是，为了安全原因，如果网页直接从文件系统中加载，很多现代浏览器不允许JavaScript发起服务器请求。为了在开发期间托管应用程序，用一个简单的静态的web服务器配置angular-phonecat项目。运行以下指令以开启web服务器。 npm start 这将创建一个本地web服务器，鉴听你的本地机器上的端口8000。现在你可以在这个地址上浏览该应用程序了： http://localhost:8000/app/index.html 进入angular-phonecat目录，运行如下命令： git checkout -f step-0 该命令将重置phonecat项目的工作目录，建议您在每一学习步骤运行此命令，将命令中的数字改成您学习步骤对应的数字，该命令将清除您在工作目录内做的任何更改。PS：从官网clone的项目会报错，版本号对不上，根据实际情况操作就可以了。可以另外打开一个命令行工具，用来切换版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[导航栏]]></title>
      <url>%2F2017%2F02%2F08%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%2F</url>
      <content type="text"><![CDATA[通过jQuery实现一个导航栏，单击不同的商品名称链接，显示相应的内容，同时高亮显示当前选择的商品。html代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://oksyeh4la.bkt.clouddn.com/default.css&quot;/&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;长袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖T恤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;长袖T恤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;卫衣&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;开襟卫衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;套头卫衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;运动卫衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;童装卫衣&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;裤子&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;休闲裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;牛仔裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;免烫卡其裤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //等待dom元素加载完毕. $(function(){ $(&quot;.level1 &gt; a&quot;).click(function(){ $(this).addClass(&quot;current&quot;) //给当前元素添加&quot;current&quot;样式 .next().show() //下一个元素显示 .parent().siblings().children(&quot;a&quot;).removeClass(&quot;current&quot;) //父元素的兄弟元素的子元素&lt;a&gt;移除&quot;current&quot;样式 .next().hide(); //它们的下一个元素隐藏 return false; }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[经过两天的折腾，终于把自己的博客搭建好了，有点小欣喜。 早就想弄一个博客，记录学习的知识和日常生活的点滴了。域名已经买了很久了，之前一直用的wordpress做后台，喜欢折腾一些网页的效果及插件，并且三天打鱼两天晒网。所以域名一直没派上什么用，买的空间也白白浪费了。 加上自己也不喜欢用wordpress写博客，觉得wp太臃肿了，写博客就应该简简单单的，没必要用到这么多的功能。所以，一开始的时候我是准备直接全手写html页面的，直到趁着过年放假有时间，折腾了一下，终于把我心目中博客该有的样子给折腾出来了，哈哈。]]></content>
    </entry>

    
  
  
</search>
