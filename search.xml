<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[十分钟学会写JQuery插件]]></title>
      <url>%2F2017%2F06%2F08%2F%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E5%86%99JQuery%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[如今做web开发，jquery 几乎是必不可少的。至于使用jquery好处这里就不再赘述了，用过的都知道。今天我们来讨论下jquery的插件机制，jquery有着成千上万的第三方插件，有时我们写好了一个独立的功能，也想将其与jquery结合起来，可以用jquery链式调用，这就要扩展jquery，写成插件形式了，如下面就是一个简单扩展Jquery对象的demo： //sample:扩展jquery对象的方法，bold()用于加粗字体。 (function ($) { $.fn.extend({ &quot;bold&quot;: function () { ///&lt;summary&gt; /// 加粗字体 ///&lt;/summary&gt; return this.css({ fontWeight: &quot;bold&quot; }); } }); })(jQuery); 调用方式： $(function () { //链式调用，加粗p标签中的字体 $(&quot;p&quot;).bold(); }) jquery的插件机制为了方便用户创建插件，jquery提供了jQuery.extend()和jQuery.fn.extend()方法。jQuery.extend() 方法有一个重载。jQuery.extend(object) ,一个参数的用于扩展jQuery类本身，也就是用来在jQuery类/命名空间上增加新函数，或者叫静态方法，例如jQuery内置的 ajax方法都是用jQuery.ajax()这样调用的，有点像 “类名.方法名” 静态方法的调用方式。下面我们也来写个jQuery.extend(object)的例子： //扩展jQuery对象本身 jQuery.extend({ &quot;minValue&quot;: function (a, b) { ///&lt;summary&gt; /// 比较两个值，返回最小值 ///&lt;/summary&gt; return a &lt; b ? a : b; }, &quot;maxValue&quot;: function (a, b) { ///&lt;summary&gt; /// 比较两个值，返回最大值 ///&lt;/summary&gt; return a &gt; b ? a : b; } }); //调用 var i = 100; j = 101; var min_v = $.minValue(i, j); // min_v 等于 100 var max_v = $.maxValue(i, j); // max_v 等于 101 重载版本：jQuery.extend([deep], target, object1, [objectN])用一个或多个其他对象来扩展一个对象，返回被扩展的对象。如果不指定target，则给jQuery命名空间本身进行扩展。这有助于插件作者为jQuery增加新方法。如果第一个参数设置为true，则jQuery返回一个深层次的副本，递归地复制找到的任何对象。否则的话，副本会与原对象共享结构。未定义的属性将不会被复制，然而从对象的原型继承的属性将会被复制。参数 deep: 可选。如果设为true，则递归合并。 target: 待修改对象。 object1: 待合并到第一个对象的对象。 objectN: 可选。待合并到第一个对象的对象。示例1：合并 settings 和 options，修改并返回 settings。 var settings = { validate: false, limit: 5, name: &quot;foo&quot; }; var options = { validate: true, name: &quot;bar&quot; }; jQuery.extend(settings, options); 结果： settings == { validate: true, limit: 5, name: &quot;bar&quot; } 示例2：合并 defaults 和 options, 不修改 defaults。 var empty = {}; var defaults = { validate: false, limit: 5, name: &quot;foo&quot; }; var options = { validate: true, name: &quot;bar&quot; }; var settings = jQuery.extend(empty, defaults, options); 结果： settings == { validate: true, limit: 5, name: &quot;bar&quot; } empty == { validate: true, limit: 5, name: &quot;bar&quot; } 这个重载的方法，我们一般用来在编写插件时用自定义插件参数去覆盖插件的默认参数。jQuery.fn.extend(object)扩展 jQuery 元素集来提供新的方法（通常用来制作插件）。首先我们来看fn 是什么东西呢。查看jQuery代码，就不难发现。 jQuery.fn = jQuery.prototype = { init: function( selector, context ) {.....}; }; 原来 jQuery.fn = jQuery.prototype，也就是jQuery对象的原型。那jQuery.fn.extend()方法就是扩展jQuery对象的原型方法。我们知道扩展原型上的方法，就相当于为对象添加”成员方法“，类的”成员方法“要类的对象才能调用，所以使用jQuery.fn.extend(object)扩展的方法， jQuery类的实例可以使用这个“成员函数”。jQuery.fn.extend(object)和jQuery.extend(object)方法一定要区分开来。 自执行的匿名函数/闭包1.什么是自执行的匿名函数?它是指形如这样的函数: (function {// code})();2.疑问 为什么(function {// code})();可以被执行, 而function {// code}();却会报错?3.分析(1). 首先, 要清楚两者的区别: (function {// code})是表达式, function {// code}是函数声明.(2). 其次, js”预编译”的特点: js在”预编译”阶段, 会解释函数声明, 但却会忽略表式.(3). 当js执行到function() {//code}();时, 由于function() {//code}在”预编译”阶段已经被解释过, js会跳过function(){//code}, 试图去执行();, 故会报错;当js执行到(function {// code})();时, 由于(function {// code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.另外， 函数转换为表达式的方法并不一定要靠分组操作符()，我们还可以用void操作符，~操作符，!操作符……例如：bootstrap 框架中的插件写法： !function($){ //do something; }(jQuery); 和 (function($){ //do something; })(jQuery); 是一回事。匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。例如： var a=1; (function()(){ var a=100; })(); alert(a); //弹出 1 一步一步封装JQuery插件接下来我们一起来写个高亮的jqury插件1.定一个闭包区域，防止插件”污染” //闭包限定命名空间 (function ($) { })(window.jQuery); 2.jQuery.fn.extend(object)扩展jquery 方法，制作插件 //闭包限定命名空间 (function ($) { $.fn.extend({ &quot;highLight&quot;:function(options){ //do something } }); })(window.jQuery); 3.给插件默认参数，实现 插件的功能 //闭包限定命名空间 (function ($) { $.fn.extend({ &quot;highLight&quot;: function (options) { var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数 this.each(function () { //这里的this 就是 jQuery对象 //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。 var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom //根据参数来设置 dom的样式 $this.css({ backgroundColor: opts.background, color: opts.foreground }); }); } }); //默认参数 var defaluts = { foreground: &apos;red&apos;, background: &apos;yellow&apos; }; })(window.jQuery); 到这一步，高亮插件基本功能已经具备了。调用代码如下： $(function () { $(&quot;p&quot;).highLight(); //调用自定义 高亮插件 }); 这里只能 直接调用，不能链式调用。我们知道jQuey是可以链式调用的，就是可以在一个jQuery对象上调用多个方法，如：$(‘#id’).css({marginTop:’100px’}).addAttr(“title”,”测试“);但是我们上面的插件，就不能这样链式调用了。比如：$(“p”).highLight().css({marginTop:’100px’}); //将会报找不到css方法，原因在与我的自定义插件在完成功能后，没有将 jQuery对象给返回出来。接下来，return jQuery对象，让我们的插件也支持链式调用。（其实很简单，就是执行完我们插件代码的时候将jQuery对像return 出来，和上面的代码没啥区别） 1//闭包限定命名空间 2 (function ($) { 3 $.fn.extend({ 4 &quot;highLight&quot;: function (options) { 5 var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数 6 return this.each(function () { //这里的this 就是 jQuery对象。这里return 为了支持链式调用 7 //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。 8 var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom 9 //根据参数来设置 dom的样式 10 $this.css({ 11 backgroundColor: opts.background, 12 color: opts.foreground 13 }); 14 }); 15 16 } 17 }); 18 //默认参数 19 var defaluts = { 20 foreground: &apos;red&apos;, 21 background: &apos;yellow&apos; 22 }; 23 })(window.jQuery); 4.暴露公共方法 给别人来扩展你的插件（如果有需求的话）比如的高亮插件有一个format方法来格式话高亮文本，则我们可将它写成公共的，暴露给插件使用者，不同的使用着根据自己的需求来重写该format方法，从而是高亮文本可以呈现不同的格式。 //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。 $.fn.highLight.format = function (str) { return &quot;&lt;strong&gt;&quot; + str + &quot;&lt;/strong&gt;&quot;; } 5.插件私有方法有些时候，我们的插件需要一些私有方法，不能被外界访问。例如 我们插件里面需要有个方法 来检测用户调用插件时传入的参数是否符合规范。6.其他的一些设置，如：为你的插件加入元数据插件的支持将使其变得更强大。完整的高亮插件代码如下： //闭包限定命名空间 (function ($) { $.fn.extend({ &quot;highLight&quot;: function (options) { //检测用户传进来的参数是否合法 if (!isValid(options)) return this; var opts = $.extend({}, defaluts, options); //使用jQuery.extend 覆盖插件默认参数 return this.each(function () { //这里的this 就是 jQuery对象。这里return 为了支持链式调用 //遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。 var $this = $(this); //获取当前dom 的 jQuery对象，这里的this是当前循环的dom //根据参数来设置 dom的样式 $this.css({ backgroundColor: opts.background, color: opts.foreground }); //格式化高亮文本 var markup = $this.html(); markup = $.fn.highLight.format(markup); $this.html(markup); }); } }); //默认参数 var defaluts = { foreground: &apos;red&apos;, background: &apos;yellow&apos; }; //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。 $.fn.highLight.format = function (str) { return &quot;&lt;strong&gt;&quot; + str + &quot;&lt;/strong&gt;&quot;; } //私有方法，检测参数是否合法 function isValid(options) { return !options || (options &amp;&amp; typeof options === &quot;object&quot;) ? true : false; } })(window.jQuery); 调用 //调用 //调用者覆盖 插件暴露的共公方法 $.fn.highLight.format = function (txt) { return &quot;&lt;em&gt;&quot; + txt + &quot;&lt;/em&gt;&quot; } $(function () { $(&quot;p&quot;).highLight({ foreground: &apos;orange&apos;, background: &apos;#ccc&apos; }); //调用自定义 高亮插件 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS面向对象的程序设计]]></title>
      <url>%2F2017%2F06%2F07%2FJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[面向对象的语言有一个标志，即拥有类的概念，抽象实例对象的公共属性与方法，基于类可以创建任意多个实例对象，一般具有封装、继承、多态的特性！但JS中对象与纯面向对象语言中的对象是不同的，ECMA标准定义JS中对象：无序属性的集合，其属性可以包含基本值、对象或者函数。可以简单理解为JS的对象是一组无序的值，其中的属性或方法都有一个名字，根据这个名字可以访问相映射的值（值可以是基本值/对象/方法）。 理解对象第一种：基于Object对象 var person = new Object(); person.name = &apos;My Name&apos;; person.age = 18; person.getName = function(){ return this.name; } 第二种：对象字面量方式（比较清楚的查找对象包含的属性及方法） var person = { name : &apos;My name&apos;, age : 18, getName : function(){ return this.name; } } JS的对象可以使用‘.’操作符动态的扩展其属性，可以使用’delete’操作符或将属性值设置为’undefined’来删除属性。如下： person.newAtt=’new Attr’;//添加属性 alert(person.newAtt);//new Attr delete person.age; alert(person.age);//undefined(删除属性后值为undefined); 对象属性类型ECMA-262第5版定义了JS对象属性中特征（用于JS引擎，外部无法直接访问）。ECMAScript中有两种属性：数据属性和访问器属性 数据属性：数据属性指包含一个数据值的位置，可在该位置读取或写入值，该属性有4个供述其行为的特性：[[configurable]]:表示能否使用delete操作符删除从而重新定义，或能否修改为访问器属性。默认为true;[[Enumberable]]:表示是否可通过for-in循环返回属性。默认true;[[Writable]]:表示是否可修改属性的值。默认true;[[Value]]:包含该属性的数据值。读取/写入都是该值。默认为undefined;如上面实例对象person中定义了name属性，其值为’My name’,对该值的修改都反正在这个位置要修改对象属性的默认特征（默认都为true)，可调用Object.defineProperty()方法，它接收三个参数：属性所在对象，属性名和一个描述符对象（必须是：configurable、enumberable、writable和value，可设置一个或多个值）。如下：（浏览器支持：IE9+、Firefox 4+、Chrome、Safari5+） var person = {}; Object.defineProperty(person, &apos;name&apos;, { configurable: false, writable: false, value: &apos;Jack&apos; }); alert(person.name);//Jack delete person.name; person.name = &apos;lily&apos;; alert(person.name);//Jack 可以看出，delete及重置person.name的值都没有生效，这就是因为调用defineProperty函数修改了对象属性的特征；值得注意的是一旦将configurable设置为false，则无法再使用defineProperty将其修改为true（执行会报错：can’t redefine non-configurable property）; 访问器属性：它主要包括一对getter和setter函数，在读取访问器属性时，会调用getter返回有效值；写入访问器属性时，调用setter，写入新值；该属性有以下4个特征：[[Configurable]]:是否可通过delete操作符删除重新定义属性；[[Numberable]]:是否可通过for-in循环查找该属性；[[Get]]:读取属性时调用，默认：undefined;[[Set]]:写入属性时调用，默认：undefined;访问器属性不能直接定义，必须使用defineProperty()来定义，如下： var person = { _age: 18 }; Object.defineProperty(person, &apos;isAdult&apos;, { get: function () { if (this._age &gt;= 18) { return true; } else { return false; } } }); alert(person.isAdult?&apos;成年&apos;:&apos;未成年&apos;);//成年 从上面可知，定义访问器属性时getter与setter函数不是必须的,并且，在定义getter与setter时不能指定属性的configurable及writable特性；此外，ECMA-262（5）还提供了一个Object.defineProperties()方法，可以用来一次性定义多个属性的特性： var person = {}; Object.defineProperties(person,{ _age:{ value:19 }, isAdult:{ get: function () { if (this._age &gt;= 18) { return true; } else { return false; } } } }); alert(person.isAdult?&apos;成年&apos;:&apos;未成年&apos;);//成年 上述代码使用Object.defineProperties()方法同时定义了_age及isAudlt两个属性的特性此外，使用Object.getOwnPropertyDescriptor()方法可以取得给定属性的特性： var descriptor = Object.getOwnPropertyDescriptor(person,&apos;_age&apos;); alert(descriptor.value);//19 对于数据属性，可以取得：configurable,enumberable,writable和value；对于访问器属性，可以取得：configurable,enumberable,get和set 创建对象使用Object构造函数或对象字面量都可以创建对象，但缺点是创建多个对象时，会产生大量的重复代码，因此下面介绍可解决这个问题的创建对象的方法 工厂模式function createPerson(name, age, job) { var o = new Object(); o.name = name; o.age = age; o.job = job; o.getName = function () { return this.name; } return o;//使用return返回生成的对象实例 } var person = createPerson(&apos;Jack&apos;, 19, &apos;SoftWare Engineer&apos;); 创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的。 构造函数模式function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.getName = function () { return this.name; } } var person1 = new Person(&apos;Jack&apos;, 19, &apos;SoftWare Engineer&apos;); var person2 = new Person(&apos;Liye&apos;, 23, &apos;Mechanical Engineer&apos;); 使用自定义的构造函数（与普通函数一样，只是用它来创建对象），定义对象类型（如：Person）的属性和方法。它与工厂方法区别在于： 没有显式地创建对象； 直接将属性和方法赋值给this对象； 没有return语句； 此外，要创建Person的实例，必须使用new关键字，以Person函数为构造函数，传递参数完成对象创建；实际创建经过以下4个过程： 创建一个对象 将函数的作用域赋给新对象（因此this指向这个新对象，如：person1） 执行构造函数的代码 返回该对象 上述由Person构造函数生成的两个对象person1与person2都是Person的实例，因此可以使用instanceof判断，并且因为所有对象都继承Object，因此person1 instanceof Object也返回真： alert(person1 instanceof Person);//true; alert(person2 instanceof Person);//true; alert(person1 instanceof Object);//true; alert(person1.constructor === person2.constructor);//ture; 虽然构造函数方式比较不错，但也存在缺点，那就是在创建对象时，特别针对对象的属性指向函数时，会重复的创建函数实例，以上述代码为基础，可以改写为： function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.getName = new Function () {//改写后效果与原代码相同，不过是为了方便理解 return this.name; } } 上述代码，创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。当然，可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果，如下所示： function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.getName = getName; } function getName() {//到处是代码，看着乱！！ return this.name; } 原型模式JS每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，它是所有通过new操作符使用函数创建的实例的原型对象。原型对象最大特点是，所有对象实例共享它所包含的属性和方法，也就是说，所有在原型对象中创建的属性或方法都直接被所有对象实例共享。 function Person(){ } Person.prototype.name = &apos;Jack&apos;;//使用原型来添加属性 Person.prototype.age = 29; Person.prototype.getName = function(){ return this.name; } var person1 = new Person(); alert(person1.getName());//Jack var person2 = new Person(); alert(person1.getName === person2.getName);//true;共享一个原型对象的方法 原型是指向原型对象的，这个原型对象与构造函数没有太大关系，唯一的关系是函数的prototype是指向这个原型对象！而基于构造函数创建的对象实例也包含一个内部指针为：[[prototype]]指向原型对象。实例属性或方法的访问过程是一次搜索过程： 首先从对象实例本身开始，如果找到属性就直接返回该属性值； 如果实例本身不存在要查找属性，就继续搜索指针指向的原型对象，在其中查找给定名字的属性，如果有就返回； 基于以上分析，原型模式创建的对象实例，其属性是共享原型对象的；但也可以自己实例中再进行定义，在查找时，就不从原型对象获取，而是根据搜索原则，得到本实例的返回；简单来说，就是实例中属性会屏蔽原型对象中的属性；原型与in操作符一句话：无论原型中属性，还是对象实例的属性，都可以使用in操作符访问到；要想判断是否是实例本身的属性可以使用object.hasOwnProperty(‘attr’)来判断；原生对象中原型原生对象中原型与普通对象的原型一样，可以添加/修改属性或方法，如以下代码为所有字符串对象添加去左右空白原型方法： String.prototype.trim = function(){ return this.replace(/^\s+/,&apos;&apos;).replace(/\s+$/,&apos;&apos;); } var str = &apos; word space &apos;; alert(&apos;!&apos;+str.trim()+&apos;!&apos;);//!word space! 原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例： function Person() { } Person.prototype.name = &apos;Jack&apos;; Person.prototype.lessons = [&apos;Math&apos;,&apos;Physics&apos;]; var person1 = new Person(); person1.lessons.push(&apos;Biology&apos;); var person2 = new Person(); alert(person2.lessons);//Math,Physics,Biology，person1修改影响了person2 组合构造函数及原型模式目前最为常用的定义类型方式，是组合构造函数模式与原型模式。构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.lessons = [&apos;Math&apos;, &apos;Physics&apos;]; } Person.prototype = { constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person getName: function () { return this.name; } } var person1 = new Person(&apos;Jack&apos;, 19, &apos;SoftWare Engneer&apos;); person1.lessons.push(&apos;Biology&apos;); var person2 = new Person(&apos;Lily&apos;, 39, &apos;Mechanical Engneer&apos;); alert(person1.lessons);//Math,Physics,Biology alert(person2.lessons);//Math,Physics alert(person1.getName === person2.getName);//true,//共享原型中定义方法 在所接触的JS库中，jQuery类型的封装就是使用组合模式来实例的！！！ 动态原型模式组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中： function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.lessons = [&apos;Math&apos;, &apos;Physics&apos;]; } if (typeof this.getName != &apos;function&apos;) {//通过判断实例封装 Person.prototype = { constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person getName: function () { return this.name; } } } var person1 = new Person(&apos;Jack&apos;, 19, &apos;SoftWare Engneer&apos;); person1.lessons.push(&apos;Biology&apos;); var person2 = new Person(&apos;Lily&apos;, 39, &apos;Mechanical Engneer&apos;); alert(person1.lessons);//Math,Physics,Biology alert(person2.lessons);//Math,Physics alert(person1.getName === person2.getName);//true,//共享原型中定义方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS学习之PhoneCat安装]]></title>
      <url>%2F2017%2F05%2F04%2FAngularJS%E5%AD%A6%E4%B9%A0%E4%B9%8BPhoneCat%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[最近开始研究AngularJS了，照着官网的教程安装了PhoneCat的实例。 安装git官网下载的很慢，所以我从360下载了git。装好了就可以使用git命令行工具了。 下载angular-phonecat运行以下命令以克隆放置在GitHub上的 angular-phonecat repository： git clone --depth=14 https://github.com/angular/angular-phonecat.git 该命令在你当前的目录中创建了angular-phonecat目录。该--depth=14的选项仅仅是告诉Git只拉下来最后的14次提交。这样使下载更小更快。把你当前的目录变成angular-phonecat。 cd angular-phonecat 安装Node.js很简单的，官网下载安装就可以了，安装好后，可以检查已经安装的node.js版本： node --version 一旦你已经在你的机器上安装了Node.js，你可以依靠运行以下代码下载该工具。 npm install 这个命令读取了angular-phonecat的package.json文件，并把以下工具下载到node_modules目录中： Bower - 客户端代码包管理工具 Http-Server - 简单的本地静态web服务器 Karma - 单元测试运行器 Protractor - 端到端测试运行器 运行npm install还将自动使用bower以把该Angular框架下载到app/bower_component目录。 运行开发Web服务器虽然Angular应用程序是纯客户端代码，而且能够直接从文件系统中，在web浏览器中打开它们，但是最好从一个HTTP web服务器中供应它们。特别是，为了安全原因，如果网页直接从文件系统中加载，很多现代浏览器不允许JavaScript发起服务器请求。为了在开发期间托管应用程序，用一个简单的静态的web服务器配置angular-phonecat项目。运行以下指令以开启web服务器。 npm start 这将创建一个本地web服务器，鉴听你的本地机器上的端口8000。现在你可以在这个地址上浏览该应用程序了： http://localhost:8000/app/index.html 进入angular-phonecat目录，运行如下命令： git checkout -f step-0 该命令将重置phonecat项目的工作目录，建议您在每一学习步骤运行此命令，将命令中的数字改成您学习步骤对应的数字，该命令将清除您在工作目录内做的任何更改。PS：从官网clone的项目会报错，版本号对不上，根据实际情况操作就可以了。可以另外打开一个命令行工具，用来切换版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[导航栏]]></title>
      <url>%2F2017%2F02%2F08%2F%E5%AF%BC%E8%88%AA%E6%A0%8F%2F</url>
      <content type="text"><![CDATA[通过jQuery实现一个导航栏，单击不同的商品名称链接，显示相应的内容，同时高亮显示当前选择的商品。html代码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://oksyeh4la.bkt.clouddn.com/default.css&quot;/&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;ul class=&quot;menu&quot;&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;衬衫&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;长袖衬衫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短袖T恤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;长袖T恤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;卫衣&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;开襟卫衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;套头卫衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;运动卫衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;童装卫衣&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li class=&quot;level1&quot;&gt; &lt;a href=&quot;#none&quot;&gt;裤子&lt;/a&gt; &lt;ul class=&quot;level2&quot;&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;短裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;休闲裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;牛仔裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#none&quot;&gt;免烫卡其裤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; //等待dom元素加载完毕. $(function(){ $(&quot;.level1 &gt; a&quot;).click(function(){ $(this).addClass(&quot;current&quot;) //给当前元素添加&quot;current&quot;样式 .next().show() //下一个元素显示 .parent().siblings().children(&quot;a&quot;).removeClass(&quot;current&quot;) //父元素的兄弟元素的子元素&lt;a&gt;移除&quot;current&quot;样式 .next().hide(); //它们的下一个元素隐藏 return false; }); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>%2F2017%2F02%2F03%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[经过两天的折腾，终于把自己的博客搭建好了，有点小欣喜。 早就想弄一个博客，记录学习的知识和日常生活的点滴了。域名已经买了很久了，之前一直用的wordpress做后台，喜欢折腾一些网页的效果及插件，并且三天打鱼两天晒网。所以域名一直没派上什么用，买的空间也白白浪费了。 加上自己也不喜欢用wordpress写博客，觉得wp太臃肿了，写博客就应该简简单单的，没必要用到这么多的功能。所以，一开始的时候我是准备直接全手写html页面的，直到趁着过年放假有时间，折腾了一下，终于把我心目中博客该有的样子给折腾出来了，哈哈。]]></content>
    </entry>

    
  
  
</search>
